Got it. I’ll break down the task at a high level first, then structure it like a lead developer planning a sprint, complete with Jira-style stories and subtasks. I’ll use Foundry for testing and provide key conceptual explanations along the way. I’ll let you know as soon as everything’s ready for your review.

# Token Fundraising Launchpad Project Plan

## High-Level Overview

This project is a **token fundraising launchpad** that enables a project team to raise funds in USD Coin (USDC) using a **bonding curve token sale**. The system comprises a **smart contract suite** (written in Solidity) and **off-chain scripts** (in TypeScript and Python) for interacting with the contracts. The main components are:

- **ERC-20 Token Contract** – An upgradable token contract (1 billion total supply) representing the project’s token. Only 500 million tokens (50% of supply) will be sold to the public via the bonding curve. The token contract is integrated with OpenZeppelin’s UUPS upgradeability pattern for future upgrades.
- **Bonding Curve Sale Contract** – A UUPS upgradable contract that manages the token sale using a **Bancor-style bonding curve**. Early buyers get more tokens per USDC, and the price increases as more tokens are sold. The sale accepts USDC and mints/releases tokens to buyers according to the bonding curve price formula. It stops selling once 500 million tokens are sold (fundraising goal reached).
- **Distribution Logic** – Upon sale completion, the sale contract automatically distributes the remaining 500 million tokens and the USDC raised as per the token economics:
  - **Fund Creator** (project team) receives 200 million tokens and 50% of the USDC raised.
  - **Uniswap Liquidity Pool** gets 250 million tokens paired with the other 50% of USDC (providing initial liquidity for trading).
  - **Launchpad Platform** (the service provider) retains a 50 million token fee as revenue.
- **Uniswap Integration** – The sale contract or a post-sale script will add the 250M tokens and corresponding USDC to a Uniswap pool (v2 or v3) to create a market for the token immediately after the sale. Liquidity providers must deposit equal values of both tokens into the pool, so the contract ensures the USDC and token amounts are equal in value when adding liquidity.
- **Off-chain Scripts** – Helper scripts in TypeScript (using Ethers.js) and Python (using web3.py) demonstrate how to interact with the contracts. For example, scripts to initiate a sale, purchase tokens (by sending USDC), finalize the sale, and query balances or pool info.
- **Deployment** – The contracts will be deployed on an EVM-compatible **testnet** (e.g., Ethereum Goerli or Polygon Mumbai). We will provide the deployed contract addresses and ensure the code is **verified** on a block explorer (like Etherscan) for transparency.
- **Architecture Summary**: The launchpad follows a **proxy pattern** for upgradeability (UUPS proxy), separating storage (proxy) from logic (implementation). The token sale logic (bonding curve, distribution) is contained in an upgradeable contract, while the token itself is a standard (but upgradeable) ERC20. Off-chain components handle user interactions and automated sequences (like adding liquidity), ensuring a complete end-to-end fundraising solution.

## Concepts Explained

**UUPS Upgradeable Proxy (ERC-1822)** – UUPS stands for *Universal Upgradeable Proxy Standard*. It is a proxy pattern for upgradeable contracts where the upgrade function resides in the implementation contract (not in the proxy itself). The proxy holds a pointer to the current implementation and delegates calls to it. Only authorized admin can trigger an upgrade, which is done by the implementation’s code updating the proxy’s stored implementation address via `delegatecall`. This design avoids clashes in function selectors and keeps the proxy lightweight. OpenZeppelin’s `UUPSUpgradeable` base contract is used to secure this pattern. In our project, at minimum the **sale contract** will use UUPS (so it can be improved or patched in future without disrupting state or needing a new address). The upgrade mechanism must be handled carefully – the implementation includes an `upgradeTo` function (from `UUPSUpgradeable`) that only the owner (admin) can call to set a new implementation address. By using UUPS, we get flexibility and lower gas costs compared to the older Transparent proxy pattern, while retaining upgradability.

**Bancor-Style Bonding Curve** – A bonding curve is a pricing mechanism where the **token price increases as the token supply increases**. In a Bancor-style continuous token model, the contract holds a reserve (in our case, USDC) and maintains a constant ratio between the reserve and the token’s market cap. The price is determined by a formula ensuring that each incremental purchase raises the price slightly. Early buyers get in at a lower price, receiving more tokens per USDC, whereas later buyers pay a higher price (fewer tokens per USDC) as the supply sold grows. Specifically, Bancor’s formula often uses a **reserve ratio (RR)**: for example, price = `ReserveBalance / (TokenSupply * RR)`. This means if the reserve ratio is small, price grows faster with each token sold (favoring early buyers). We will calibrate the curve so that selling 500 million tokens raises the target amount of USDC (the fundraising goal) and results in a reasonable final price. The contract will likely use a mathematical function or iterative calculation (`calculatePurchaseReturn` similar to Bancor formula) to determine how many tokens to mint for a given USDC contribution, or vice versa. For simplicity, we might set an initial token price (when 0 tokens sold) and a final token price (when 500m sold), and derive a curve (e.g., an exponential or polynomial curve) that smoothly transitions between them. The key property is **continuous price adjustment**: each purchase re-calculates the price so that the system’s predetermined curve (price vs. supply) is maintained. Early participants thus benefit from lower prices, and the increasing price naturally caps the total tokens that can be bought for a given budget, helping the sale reach its cap gradually.

**ERC-20 Supply Control** – The token contract will implement the ERC-20 standard for fungible tokens. Managing the supply is crucial given the fixed cap of 1,000,000,000 tokens. We will use OpenZeppelin’s ERC20 implementation for safety. There are two approaches:
- *Pre-minting*: Mint the entire 1 billion supply at deployment (to the sale contract or a distribution contract). The sale contract then distributes 500M to buyers over time and holds the rest for distribution (founder, liquidity, platform) at the end. This approach keeps supply constant but requires careful tracking of which tokens are sold vs reserved.
- *Mint-on-demand*: Start with zero or a small initial supply and **mint tokens as they are sold** and when the sale finalizes. We can cap the minting so that total minted never exceeds 1 billion. For example, each buy transaction calls the token contract’s `mint()` (allowed for the sale contract) to issue the appropriate amount of tokens to the buyer. On sale finalization, the contract mints the allocations for the founder (200M), platform (50M), and liquidity (250M) to the appropriate addresses. The sum minted will then equal 1 billion. This approach ensures no tokens exist until needed, and no unsold tokens remain idle. We will implement a **minting mechanism with access control**, likely using OpenZeppelin’s `ERC20PresetMinterPauser` or a custom ERC20 where the sale contract is granted the MINTER role. This way, only the sale contract can mint tokens during the process, preserving supply integrity.
- The ERC20 will also include typical features: name, symbol, decimals (likely 18 for compatibility, unless mimicking USDC’s 6 decimals for consistency in price calculations).
- Throughout the sale, the contract tracks how many tokens have been sold to not exceed 500M. If a purchase would exceed the cap, the contract can either reject the excess or only sell up to the cap and refund the remainder of USDC.
- After final distribution, the token’s minting function can be disabled or the minter role revoked (no further minting) to lock the supply at 1 billion permanently. This ensures token economics are fixed post-IDO.

**Uniswap Liquidity Provision** – Uniswap is a decentralized exchange using an Automated Market Maker (AMM). In an AMM, a liquidity pool holds two tokens and allows swaps according to a constant product formula *x*y = k*. To create a market for our token immediately after the sale, we will add liquidity to Uniswap (likely Uniswap V2 for simplicity, though V3 could be used similarly by concentrating around initial price). Adding liquidity means depositing **equal values of both tokens** (project token and USDC) into the pool. For example, if at sale end the token’s final price is $0.10, then adding 250 million tokens and $25 million USDC would be equal value (assuming USDC is $1) and set the initial pool price around $0.10 per token. The contract will use Uniswap’s Router contract to call `addLiquidity(token, USDC, tokenAmount, usdcAmount, ...)`. This will transfer the specified amounts to the Uniswap pair contract, creating pool shares (LP tokens). The **resulting LP tokens** (representing the pool ownership) can be kept by the project team or sent to a governance contract – this detail can be decided by the fund creator. The important concept is that the **launchpad ensures immediate market liquidity** for investors: right after the sale, buyers can trade the token on Uniswap, and the large initial liquidity (250M tokens paired with matching USDC) helps stabilize the price and reduce volatility or slippage. This addresses the common IDO requirement of *immediate trading availability*, preventing a scenario where contributors cannot sell because the token isn’t listed. We will likely target Uniswap V2 on a testnet; if Uniswap isn’t readily available on that testnet, we might deploy a minimal Uniswap factory or use an established fork (for testing, one could simulate the pool in the test environment).

**Token Economics & Distribution** – The economic design ensures fair distribution and incentives:
- **Public Sale (Investors)**: 500,000,000 tokens (50%) are sold to the public via the bonding curve. This portion raises USDC for the project. Early buyers benefit from lower prices, and late buyers pay higher prices – a fair market-driven allocation.
- **Project Team (Fund Creator)**: 200,000,000 tokens (20%) are allocated to the team. Instead of releasing these upfront, the plan is to distribute them **after** the sale to align with the fundraising success. The team also receives **50% of the USDC raised**, which provides them the capital for development. By splitting the USDC with the liquidity pool, the team gets immediate funds while still ensuring the token has strong backing on the market.
- **Liquidity Pool**: 250,000,000 tokens (25%) are set aside for liquidity. Pairing these with the other half of the USDC raised creates a robust liquidity pool on Uniswap. This is essentially “locking” half the proceeds into the market to bootstrap trading. It benefits investors by providing an avenue to trade, and it benefits the project by establishing a market price and potentially earning trading fees through the LP tokens.
- **Platform Fee**: 50,000,000 tokens (5%) are taken by the launchpad platform as a fee for hosting the sale. This is a common model where launchpads earn a portion of tokens for their service. Those tokens might be held by the platform or burned or otherwise used (e.g., sold slowly or staked). In our case, we will simply transfer the fee tokens to a platform-owned address on finalize. This fee structure incentivizes the launchpad to facilitate successful sales.
- **Total Supply Integrity**: All these allocations sum to 1 billion, which matches the fixed cap. No additional tokens will be minted beyond this. If the sale does not sell out completely (if it ended by time or manually), we would have to decide what to do with unsold tokens (perhaps burn or reallocate), but in our scenario, the sale is structured to reach exactly the goal (sells 500M).
- **Price Dynamics & Post-Sale**: Because of the bonding curve, the final price per token at the end of the sale will be higher than the starting price. When liquidity is added, we need to ensure the ratio of tokens to USDC in the pool reflects roughly that final sale price to avoid immediate arbitrage. For example, if final price was $0.10, we add liquidity at that price. Post-sale, the market price may move based on supply and demand, but the large liquidity will make it harder to dramatically sway the price (preventing huge dumps or pumps initially).
- **Refunds and Failsafes**: The contracts will likely include safeguards. For instance, the ability for the fund creator to halt the sale in emergencies (withdrawing remaining tokens and USDC) or an investor refund mechanism if the sale is aborted. These are additional considerations (not explicitly in the requirements, but good to mention for completeness). At minimum, the finalize function will be protected so only the fund creator (or the contract itself when conditions met) can execute the final distribution.

By combining these concepts – upgradeable smart contracts, a dynamic pricing curve, controlled token supply, and automated liquidity provisioning – the launchpad provides a modern approach to token fundraising (akin to an **Initial DEX Offering (IDO)**) that is fair, transparent, and immediately market-accessible.

## Development Plan

We will structure development in an agile, sprint-like manner with **Epics** (major components or goals), each broken into **User Stories** (features or milestones), which are further divided into **1-point Subtasks** (bite-sized tasks ideally done in a day or less). Each subtask is marked with the type of test expected: **(Unit Test)** for isolated contract logic tests or **(Integration Test)** for end-to-end scenario tests in Foundry.

### Epic 1: Smart Contract Development 
*Goal*: Implement and deploy the core smart contracts (token and sale) with required features and upgradeability.

- **Story 1: ERC20 Token Contract Implementation** – Create the token that will be sold and distributed.
  - Subtask: Define ERC20 token contract with name, symbol, decimals, and a fixed cap of 1,000,000,000 tokens *(Unit Test)*.
  - Subtask: Integrate OpenZeppelin’s ERC20 and access control (e.g., `ERC20Upgradeable`, `UUPSUpgradeable`, `AccessControl`) to allow only the sale contract to mint tokens *(Unit Test)*.
  - Subtask: Implement an `initialize()` function (since using UUPS proxy) for setting up token name, symbol, and assigning the sale contract the MINTER role *(Unit Test)*.
  - Subtask: Write unit tests for token functionality: total supply cap, only authorized minter can mint, transfers work, decimals, etc. *(Unit Test)*.
  - Subtask: Write unit tests specifically for upgradeability: e.g., try upgrading the token (via a test implementation) to ensure the UUPS `upgradeTo` is restricted to admin *(Unit Test)*.

- **Story 2: Bonding Curve Sale Contract Implementation** – Develop the crowdfunding logic with the bonding curve.
  - Subtask: Define state variables for tracking tokens sold, USDC raised, sale parameters (curve constants, addresses for USDC, token, fund creator, platform) *(Unit Test)*.
  - Subtask: Implement `initialize(tokenAddress, usdcAddress, fundCreatorAddr, platformAddr, parameters...)` to set initial state and ensure it’s called only once (UUPS initializer) *(Unit Test)*.
  - Subtask: Implement the **bonding curve pricing** function. This function will calculate how many tokens to mint for a given USDC contribution (or vice versa). We might implement `buyTokens(uint256 usdcAmount)` that returns tokens awarded, using a formula or iterative approximation. Use math libraries for precision as needed (consider fixed-point math for fractional token per USDC pricing) *(Unit Test)*.
  - Subtask: Implement the **purchase** function (e.g., `buyTokens(uint256 usdcAmount)`): 
    - Transfers `usdcAmount` from buyer to the contract,
    - Calculates token amount via bonding curve,
    - Mints that many tokens to buyer (through token contract),
    - Updates internal counters (tokens sold, USDC raised),
    - Possibly emits an event (Purchase event with buyer, USDC spent, tokens bought, new price) *(Unit Test)*.
  - Subtask: Ensure the purchase function prevents overselling beyond 500M tokens. If a purchase would exceed remaining tokens, handle appropriately (sell only up to cap and refund rest, or disallow) *(Unit Test)*.
  - Subtask: Implement a **finalize** function to be called when exactly 500M tokens have been sold (or sale duration ended, depending on design). This function will:
    - Mint/transfer 200M tokens to fund creator’s address,
    - Mint/transfer 50M tokens to platform’s address,
    - Add liquidity with 250M tokens + equivalent USDC to Uniswap pool (via Uniswap Router call),
    - Transfer LP tokens (if any) to the fund creator (or maybe lock them in contract for time lock; but we assume immediate control by fund creator),
    - Mark the sale as finalized (so no further purchases allowed) *(Integration Test)*.
  - Subtask: Implement safety checks in finalize: only callable by fund creator or automatically when conditions met; only runs once; reverts if the sale isn’t complete or if adding liquidity fails *(Unit Test)*.
  - Subtask: Write unit tests for the bonding curve math in isolation: test that small USDC amounts yield higher token per USDC than larger amounts (price increases). Use specific scenarios to validate the curve formula (e.g., buying in increments and checking price changes) *(Unit Test)*.
  - Subtask: Write unit tests for purchase function: buying tokens updates balances correctly, caps at 500M, events emitted, only accepts valid USDC (perhaps test with a mock USDC token contract for simplicity) *(Unit Test)*.
  - Subtask: Write a unit test for the finalize distribution: simulate a scenario where 500M tokens sold and ensure finalize sends correct tokens to each party and calls the Uniswap router. This might involve using a **mock Uniswap router contract** in unit tests to capture the `addLiquidity` call and verify it receives 250M tokens & USDC *(Unit Test)*.

- **Story 3: Proxy and Upgradeability Implementation** – Set up the upgradable proxy pattern for both contracts.
  - Subtask: Deploy the token and sale contracts as **UUPS** proxies (in tests/deployment scripts). Ensure OpenZeppelin’s `UUPSUpgradeable` is inherited and an `upgradeTo` function is present in each logic contract *(Integration Test)*.
  - Subtask: Implement ownership/admin mechanism for upgrades (e.g., using OpenZeppelin’s `OwnableUpgradeable` or `AccessControl`). The deployer (platform admin) will be the default admin who can upgrade. Test that only the admin can upgrade, and a dummy new implementation can be set (in a test context) *(Unit Test)*.
  - Subtask: Write a test simulating an upgrade: deploy a new version of the sale contract (maybe with a changed variable or logic), call `upgradeTo` via the proxy, then verify state is preserved and new logic is in effect *(Integration Test)*.
  - Subtask: Write integration tests for the overall upgradeable deployment: e.g., deploying proxies, initializing, then performing purchases and finalize through the proxy addresses to ensure the proxies forward correctly *(Integration Test)*.

### Epic 2: Off-Chain Interaction Scripts 
*Goal*: Build scripts in TypeScript and Python for users or developers to interact with the system (buy tokens, finalize sale, etc.), and to automate actions like adding liquidity (if not done on-chain).

- **Story 1: TypeScript Interaction Scripts (Ethers.js)** – Provide a Node.js script suite for common interactions.
  - Subtask: Set up a Node.js project with Ethers.js and (optionally) TypeChain for contract types. Connect to the chosen testnet via Infura/Alchemy or an Ethereum provider *(Unit Test)*.
  - Subtask: Write a **script to initiate a sale** (if our design allows dynamically starting a new sale event). This might involve deploying new proxy instances of the contracts (if each sale is separate). If the sale is already deployed, this step might simply be configuration, so possibly skip if not multi-sale.
  - Subtask: Write a **buy script** (e.g., `buyTokens.ts`) that takes an investor’s address/key and amount of USDC to contribute. The script:
    - Approves the sale contract to spend the investor’s USDC (calls USDC token’s `approve`),
    - Calls the sale contract’s `buyTokens` function,
    - Logs the result (tokens received, new price or sale progress) *(Integration Test)*.
  - Subtask: Write a **finalize script** (`finalizeSale.ts`) for the fund creator to trigger distribution once sale is complete. The script calls `finalize` on the sale contract from the fund creator’s account and logs the outcome (perhaps fetching final balances of creator, platform, checking Uniswap pool state) *(Integration Test)*.
  - Subtask: Write a **script to check balances** (`checkBalances.ts`) that queries the token balance of any address and the USDC balance collected in the sale contract, to help in monitoring during test/demo *(Unit Test)*.
  - Subtask: If the sale contract did not itself add liquidity, write a **script to add liquidity via Uniswap**. This would use Uniswap SDK or direct contract calls:
    - Approve Uniswap router to spend fund creator’s 250M tokens and USDC,
    - Call `router.addLiquidity` with the token and USDC addresses and specified amounts,
    - On success, output the new pair address or LP token amount. *(Integration Test)*.
    - (If liquidity was added in `finalize` on-chain, this script may not be needed.)
  - Subtask: Test these scripts against a local blockchain (Anvil or Hardhat network) to ensure they work: simulate a full flow where a user buys tokens and then finalize is called *(Integration Test)*.

- **Story 2: Python Interaction Script (web3.py)** – Provide a Python script demonstrating similar interactions.
  - Subtask: Set up a Python environment with `web3.py` configured for the testnet (including loading ABI definitions for our contracts, possibly via compiled artifact JSONs) *(Unit Test)*.
  - Subtask: Write a **purchase script** in Python (e.g., `buy_tokens.py`) which mirrors the TS script: it should approve USDC and call the `buyTokens` function for a given user wallet. This will showcase that a developer/user can interact using Python just as easily *(Integration Test)*.
  - Subtask: Write a **status query script** (e.g., `sale_status.py`) that reads contract state: total USDC raised, tokens sold so far, current token price (if available or can be derived), time remaining, etc. This helps observers track the sale progress *(Unit Test)*.
  - Subtask: Document how to run the Python scripts (in README), and test them in a dry-run (for example, using Ganache or connecting to testnet after deployment) *(Integration Test)*.

- **Story 3: Multi-user Simulation (Integration Test)** – Create a script or test simulating multiple buyers and the entire sale lifecycle.
  - Subtask: Using either a Foundry script, Hardhat task, or a standalone Node script, simulate several users buying at different times:
    - User A buys early (should get low price, high tokens/USDC).
    - User B buys mid-way.
    - User C buys near the end (high price, fewer tokens/USDC).
    - Verify the price increases each time and the total sold and USDC match expectations *(Integration Test)*.
  - Subtask: Simulate the sale reaching exactly 500M tokens sold (might require last buyer to buy the remainder). Then call finalize (via script or directly in the test) *(Integration Test)*.
  - Subtask: After finalize, query all relevant balances:
    - Fund creator’s token balance = 200M,
    - Platform’s token balance = 50M,
    - Check the Uniswap pair contract to ensure it received 250M tokens and equivalent USDC (this can be done by reading the pair’s reserves via Uniswap pair ABI) *(Integration Test)*.
    - Possibly verify that the total USDC in fund creator’s wallet increased by the correct amount (half of the raise) *(Integration Test)*.
  - Subtask: The simulation can output or log these values as a report. We should assert in the test that these values are correct to automatically validate the distribution *(Integration Test)*.

### Epic 3: Testing and Quality Assurance 
*Goal*: Rigorously test all aspects of the system (using Foundry’s Forge for both unit and integration tests) and ensure security and correctness.

- **Story 1: Unit Test Coverage for Contracts** – Ensure all critical functions are unit tested in isolation.
  - Subtask: Test **Token minting controls** – attempts to mint by unauthorized addresses should fail, authorized minting succeeds up to cap *(Unit Test)*.
  - Subtask: Test **Bonding curve math** with small and edge values – e.g., 1 USDC yields X tokens, 1,000,000 USDC yields fewer tokens per USDC. Possibly test extreme: full 500M tokens sold in one go yields correct USDC (the goal amount) *(Unit Test)*.
  - Subtask: Test **Purchase function** edge cases – buying 1 token worth of USDC, buying just below and above the cap, ensuring no more than 500M tokens can be bought *(Unit Test)*.
  - Subtask: Test **Finalize pre-conditions** – calling finalize too early (should fail), calling by non-authorized if restricted (should fail), calling after already finalized (should fail) *(Unit Test)*.
  - Subtask: Use Foundry’s fuzz testing where applicable, e.g., fuzz the USDC amount input to `buyTokens` to see if any math overflow or precision issue occurs. Use invariants if possible (e.g., an invariant that reserve ratio remains within expected range, or total supply never exceeds 1B) *(Unit Test)*.

- **Story 2: Integration Tests for Workflows** – Use Foundry to simulate realistic scenarios and end-to-end flows.
  - Subtask: **Test full sale lifecycle** – Deploy fresh contracts in a Foundry test, have one or more addresses buy tokens in sequence (as in the multi-user simulation above), then finalize. Assert final balances as expected *(Integration Test)*.
  - Subtask: **Test partial sale scenario** – (If applicable) simulate scenario where sale period ends before 500M sold (this requires a time limit feature which wasn’t explicitly stated but a real launchpad might have). Ensure that finalize still distributes proportional funds or allows the creator to reclaim unsold tokens. *(Integration Test)*.
  - Subtask: **Test upgrade process** – in a test, deploy v1 of sale contract, perform some buys, upgrade to v2 (which maybe changes a rate or fixes a bug), continue the sale, and verify continuity. This builds confidence in the UUPS upgradability working as designed *(Integration Test)*.
  - Subtask: **Security tests** – Ensure important security properties:
    - Only USDC is accepted (e.g., if someone tries to send ETH or another token directly it’s handled or stuck; though as a sale contract, it likely won’t accept ETH at all).
    - Re-entrancy protection if any external calls (e.g., adding liquidity calls an external router; ensure state updates done before that call or use reentrancy guard if needed).
    - Math does not overflow (use OpenZeppelin’s SafeMath or solidity 0.8 built-in checks).
    - The funds (USDC) collected remain in contract until finalize – test that the contract’s USDC balance matches `USDC raised` counter at all times *(Integration Test)*.
    - If using an oracle or price feed for something (likely not, bonding curve is independent), test its failure modes.
    - The `finalize` yields correct Uniswap interaction: possibly fork mainnet in Foundry and simulate adding liquidity to real Uniswap contracts (this could be an advanced test, by impersonating the sale contract and interacting with a known USDC/token pair). If too complex, rely on unit tests with a mock router. *(Integration Test)*.

- **Story 3: Test Documentation and CI** – Set up continuous integration and clearly document how to run tests.
  - Subtask: Create a script or npm task for running Foundry tests (e.g., `forge test` with a specific fork config if needed) *(Unit Test)*.
  - Subtask: Document in the README how to run tests, and what each major test suite covers. For example, separate Foundry test files: `Token.t.sol` for token tests, `Sale.t.sol` for sale logic, `Integration.t.sol` for full flow scenarios *(Documentation)*.
  - Subtask: If using GitHub, set up a CI workflow (GitHub Actions) to run `forge test` on push, ensuring tests pass consistently *(Unit Test)*.
  - Subtask: Aim for high coverage – optionally, generate a coverage report using a tool like Foundry’s coverage or another solidity coverage tool, and include results.

### Epic 4: Deployment & Verification 
*Goal*: Deploy the system on a public testnet, verify the contracts, and prepare for a potential mainnet launch.

- **Story 1: Deployment Preparation** – Set up configs and accounts for testnet deployment.
  - Subtask: Choose a testnet (e.g., **Goerli** for Ethereum, or **Mumbai** for Polygon for lower costs). Ensure USDC is available on this testnet (Goerli USDC exists as a mock or one can use a USDC-equivalent test token).
  - Subtask: Obtain testnet credentials: a funded testnet account (private key or mnemonic) for deploying contracts and simulating users. Configure environment variables for private keys, RPC endpoints.
  - Subtask: Configure deployment scripts (in Foundry or Hardhat): network RPC URL, chain ID, contract constructor parameters or initializer parameters, gas price if needed *(Unit Test)*.
  - Subtask: If using Foundry, write a `forge script` in Solidity or use Foundry’s CLI to deploy the proxy and implementation. If using Hardhat, write a deploy script (JavaScript/TypeScript) that uses `deployProxy` utilities from OpenZeppelin Upgrades or manually deploys and calls initialize *(Unit Test)*.
  - Subtask: Include logic to **verify** contracts on a block explorer. For example, Hardhat Etherscan plugin or Foundry’s `forge verify-contract` for both the implementation contract and the proxy (if required). This will upload the source code and make the contract publicly verified.

- **Story 2: Testnet Deployment Execution** – Deploy and validate the contracts on the chosen network.
  - Subtask: Deploy the ERC20 token proxy & implementation. Save the addresses (implementation address and proxy address) and ensure the proxy is initialized properly (name, symbol, decimals, and sale contract’s address if needed). Confirm total supply is 0 (if mint-on-demand) or 1B (if pre-minted) as expected.
  - Subtask: Deploy the Sale contract proxy & implementation. Initialize with addresses for token, USDC (testnet USDC address or a deployed mock), fund creator, platform, and any curve parameters needed (initial price, reserve ratio, etc.).
  - Subtask: After deployment, call a simple status function (if exists) or read public variables to ensure everything is configured. For example, check that sale’s token = our token address, token’s minter role includes sale address, etc. *(Integration Test)*.
  - Subtask: Run a quick **test purchase** on testnet (with a small USDC amount) to ensure the system works outside of local tests. This can be done with the TS script or manually via Etherscan’s write interface. Verify that the buyer received tokens and the contract’s USDC increased. This serves as a sanity check post-deployment *(Integration Test)*.
  - Subtask: Execute the **finalize** on testnet once ready (we might not actually run through 500M tokens on a testnet due to time and funding constraints; instead, possibly simulate reaching goal by temporarily adjusting parameters or calling finalize directly for demo). Ensure finalize runs without issues – check that the founder got tokens, platform got tokens, and liquidity was added (verify the Uniswap pair contract exists and has reserves).
  - Subtask: Save the **contract addresses**: Token (proxy) address, Sale (proxy) address, perhaps the Uniswap Pair address. Verify these on a block explorer and note the links for the write-up.

- **Story 3: Verification and Audit** – Verify source code and consider a review for security.
  - Subtask: Verify the contracts on Etherscan (or Polygonscan, etc.). This involves providing the flattened source or using API via Hardhat/Foundry. Ensure both the implementation and the proxy (if applicable) are verified. The proxy might be just OpenZeppelin’s standard proxy code – verifying the implementation is most important so others can read the logic.
  - Subtask: Double-check the proxy admin and upgrade settings on the explorer. Possibly verify that the proxy’s admin is set to the deployer (or an admin contract) and that the implementation address matches our deployed logic.
  - Subtask: Conduct an internal **audit checklist**: run through known Ethereum security issues (reentrancy, integer overflow, access control, initialization front-running, etc.) and ensure our contracts mitigate them. This isn’t a formal audit but a QA step. Document any measures (like using OpenZeppelin libraries, using `ReentrancyGuard` if needed, etc.) in the README.
  - Subtask: If any critical issues are found in testing or this review, fix them and redeploy (hence the advantage of upgradeability: if minor issues, perhaps an upgrade can patch it without redeploying everything).
  - Subtask: Note in documentation that this is a testnet deployment and not an audit-approved mainnet deployment yet. For a real launch, a professional audit would be recommended.

### Epic 5: Documentation & Repository Setup
*Goal*: Prepare comprehensive documentation and organize the repository for easy understanding and evaluation.

- **Story 1: Code Documentation** – Write natspec and code comments.
  - Subtask: Add **NatSpec comments** to all public/external functions in the Solidity contracts (explaining what the function does, its parameters, return values) for clarity. For example, document `buyTokens` to explain it takes USDC and mints tokens at current price.
  - Subtask: Comment the logic of the bonding curve formula in-code, so other developers can follow the math. If a specific formula from Bancor or otherwise is used, reference it or provide a link in comments.
  - Subtask: Document the meaning of each important state variable (especially if formula parameters are stored, like reserve ratio or coefficient).
  - Subtask: Generate a doc (if possible) from the NatSpec using a tool or just rely on the comments being in the code on Etherscan.

- **Story 2: README and Write-up** – Create a detailed README.md for the GitHub repository (see “Writeup Guide” section for contents).
  - Subtask: Write an **Introduction** in the README describing the project’s purpose, how it works at a high level, and summarizing the outcome (token distribution, etc.).
  - Subtask: Write a section on **How to Run** – including prerequisites (Foundry installation, Node.js, Python etc.), how to install dependencies, compile contracts (`forge build` or `npm install` etc.), how to run tests (`forge test`), and how to run the provided scripts.
  - Subtask: Write a **Deployment** section – describing how to use the scripts to deploy to a network, or how the provided deployment was done (with specific addresses on testnet, transaction hashes if available). Include the contract addresses and links to their Etherscan verification.
  - Subtask: Write a **Usage** section – how an end-user or developer can use the deployed contracts. E.g., “To participate in the sale, call `buyTokens` via our frontend or Etherscan, sending USDC. To upgrade the contract, use `upgradeTo` (admin only). After the sale, trading is available on Uniswap at [pair address].”
  - Subtask: Write about **Token Economics** in the README – clearly state the numbers (50% sale, 20% team, etc.) and rationale, possibly linking back to any sources or this document to justify the bonding curve approach.
  - Subtask: Include a **Security Considerations** section – note any important aspects like upgradability (e.g., trust in the admin not to rug pull via upgrade), the need to secure the private key that can upgrade, how the funds are secured, etc.
  - Subtask: Ensure the README serves as the “write-up” needed for submission: it should effectively convince the reader that the implementation meets all requirements and explain the design decisions.

- **Story 3: Repository Structure & Cleanup** – Organize the repository in a logical manner.
  - Subtask: Create a clear structure:
    - `src/` (or `contracts/`) directory for Solidity contracts (perhaps `Token.sol`, `Sale.sol`, plus any libraries or interface contracts, e.g., `IUniswapV2Router.sol` for router interface).
    - `scripts/` directory for deploy and interaction scripts (with subfolders or naming to distinguish TS vs Py scripts, e.g., `scripts/BuyTokens.ts`, `scripts/buy_tokens.py`).
    - `test/` directory for Foundry tests (Solidity `.t.sol` files, possibly mirrored naming of the contract under test).
    - `lib/` for external libraries (we might use git submodules or Foundry’s package management to include OpenZeppelin contracts, Uniswap interfaces, etc.).
    - project config files like `foundry.toml`, `package.json` (for TypeScript project), and a requirements file for Python if needed.
  - Subtask: Remove any unused files or sample code (for example, if we started from a template, ensure only relevant code remains).
  - Subtask: Double-check that all secrets (private keys, etc.) are excluded from the repo. Use `.env` for secrets and list it in `.gitignore`. Document how to set up these env variables for deployment scripts.
  - Subtask: Final sanity check: ensure the repo can be cloned and instructions followed to reproduce deployment and tests. This likely means doing a fresh clone ourselves and following the README steps.

By following this development plan, we break down the complex project into manageable pieces. Each subtask being “1-point” ensures we can estimate and track progress, and importantly, every story is accompanied by thorough tests (unit and integration) to catch issues early. The approach is iterative: for example, we can implement and test the token first, then the sale, then integration, rather than a big bang. This plan also leaves room to adjust if any assumptions (like availability of Uniswap on testnet) change, since we have clearly isolated concerns.

## Tools and Frameworks

We will use a modern Ethereum development stack, choosing tools that ensure security, efficiency, and developer experience:

- **Solidity (0.8.x)**: The core smart contract language for writing the token and sale contracts. Solidity 0.8+ has built-in overflow checks and is well-supported by libraries. It’s the natural choice for EVM contracts.
- **OpenZeppelin Contracts**: A proven library of secure smart contract components. We will leverage OpenZeppelin for:
  - ERC20 implementation (for standard functionality and to save time),
  - UUPS upgradeability base (using `UUPSUpgradeable` and `Initializable` mixins to easily make our contracts upgradeable),
  - AccessControl or Ownable for permissioning (so only authorized addresses can perform certain actions like minting or upgrading).
  Using OpenZeppelin reduces risk by using audited code for standard features.
- **Foundry (Forge and Cast)**: Foundry is a fast, powerful toolkit for Solidity development and testing. We choose Foundry for:
  - **Unit and Integration Testing**: Forge tests are written in Solidity, which allows direct interaction with contracts and fine-grained control (including cheatcodes for warping time or manipulating state in tests). This means our tests run at the same level as our code, enabling complex scenarios and even fuzz testing with ease.
  - **Scripting/Deployment**: Foundry can execute Solidity scripts with `forge script` and can interact with the blockchain via Cast. It’s possible to write deployment scripts in Solidity or use Cast to send transactions. This keeps the toolset unified. (However, we might also use Hardhat for certain scripting conveniences, as noted below).
  - **Performance**: Foundry is known for blazing fast test execution and ability to fork mainnet state for testing interactions with real protocols (useful if we want to simulate Uniswap).
- **Hardhat (for auxiliary scripting & Etherscan verification)**: While Foundry covers compilation and testing, Hardhat can complement in certain areas:
  - Writing scripts in TypeScript using Hardhat and Ethers.js is straightforward, especially for complex deployments or integration with other systems. We might use Hardhat’s environment for deploying the proxies using OpenZeppelin Upgrades plugin (which simplifies UUPS deployments).
  - Hardhat’s Etherscan verification plugin is a convenient way to verify contracts. Foundry also has verification, but either is fine. We’ll use whichever integrates best in our pipeline.
  - Hardhat could also be used for tasks like a console or running a local node, but Foundry’s Anvil node can serve for local testing similarly.
  - If using Hardhat, we will integrate **TypeChain** to generate TypeScript typings for our contracts – this improves the safety of our TS scripts by providing correct method signatures and data types.
- **Ethers.js**: A lightweight JavaScript library to interact with Ethereum. In our TS scripts, we use Ethers to handle signing transactions, calling contract methods, and listening to events. Ethers is well-suited for script automation and is compatible with both Hardhat and Foundry (we can attach Ethers to Foundry’s Anvil or any RPC).
- **TypeScript**: Ensures our interaction scripts are typed and easier to maintain. With TypeScript and TypeChain, calling a contract method is type-checked, reducing errors. We will use TS for the Node scripts (purchase, finalize, etc.) as part of the repository.
- **web3.py (Python)**: For the Python script, we’ll use the `web3` library which is the de facto Python EVM library. It will allow us to load contract ABIs and call functions from a Python environment. This is mostly to demonstrate cross-language accessibility; `web3.py` will handle converting types and sending transactions via an HTTP provider.
- **Uniswap SDK or Direct Contracts**: To add liquidity, we have two choices:
  - Use the **Uniswap V2 Contracts** directly. We can include the Uniswap V2 Router interface (IUniswapV2Router02) in our project, which allows our contract (or script) to call `addLiquidity`. This is likely easier in solidity (the sale contract can call router) or via ethers in a script. We will have the address of the Uniswap Router on the testnet (if Uniswap is deployed there; if using a local fork, we deploy the factory/router ourselves).
  - Optionally, the **Uniswap SDK (JavaScript)** can be used off-chain to compute things like amounts or to find the pair address, but since we know exactly what we want to add (250M tokens, X USDC), we might not need the full SDK. The SDK is more useful for swapping or complex pool interactions.
  - For testing, we might deploy a minimal Uniswap environment. There are tools/scripts to deploy Uniswap V2 locally for testing. We could incorporate that in Foundry by deploying Uniswap contracts within a test to simulate the addLiquidity end-to-end.
- **Git & GitHub**: For version control, obviously. We will use GitHub to host the repository. Possibly use GitHub Actions for CI to run tests on each commit.
- **Linters/Formatters**: We will use Prettier (for TS code) and perhaps Solhint/Solium or Foundry’s fmt for Solidity, to maintain code style and catch common errors.
- **Remix or Brownie (optional for debugging)**: During development, if needed, we could use Remix IDE or Brownie to quickly prototype or test interactions with the contracts. But our main stack is Foundry + Hardhat.
- **Testing Framework**: Foundry’s own testing satisfies our needs (which uses built-in cheat codes and assertions). We may not need additional assertion libraries; Foundry gives us `vm` cheatcodes and the Forge stdlib (which has `stdError` for expect reverts, etc.). If Hardhat was used for some reason in tests, Mocha/Chai would be the framework, but we prefer Foundry’s native approach.

**Justification**: This stack is chosen for **security** (OpenZeppelin, well-audited base contracts), **upgradeability** (UUPS pattern per OpenZeppelin’s recommendation), and **developer efficiency** (Foundry’s fast compile/test cycle, Hardhat’s rich plugin ecosystem, Ethers for easy scripting). By using both TS and Python, we demonstrate the interoperability of our smart contracts with multiple languages and tools, which is useful for different developer audiences (some might want a Node.js script, others might prefer a Python environment). Uniswap integration is handled at the contract level and/or via known libraries, reducing the complexity of implementing AMM logic ourselves (we rely on Uniswap’s battle-tested contracts for the exchange mechanism). Overall, this toolset covers the entire development lifecycle: design, implementation, testing, deployment, and operation.

## Deployment Plan

Deploying an upgradeable token sale involves multiple steps and careful coordination. We will outline both **manual steps** (for clarity) and potential **automation** (scripts or CI) to deploy and verify the contracts on a test network.

**Prerequisites**:
- Decide on a testnet: **Goerli (Ethereum)** is a good choice as it has a USDC test token (Circle may have a Goerli USDC, or we use an equivalent stablecoin). Alternatively, **Polygon Mumbai** could be used with a mocked USDC. For this plan, we assume Goerli.
- Ensure we have the **Uniswap environment** ready on the testnet:
  - On Goerli, Uniswap V2 might not be deployed by default. We could deploy our own Uniswap factory & router, but that’s complex. Instead, we might use Uniswap **V3** which is deployed on Goerli (but adding liquidity in V3 is more complex due to NFTs and price ranges).
  - Simpler: use SushiSwap on Goerli (Sushi is a Uniswap v2 fork and often deployed on testnets). Or use an existing public AMM on the chosen chain.
  - If none is available, we can deploy a minimal Uniswap V2 for our testing purposes. For actual demonstration, we could even treat our own sale contract as a pseudo-AMM by allowing trading, but that diverges from requirements.
  - We’ll plan assuming Uniswap V2 or equivalent is available or we will deploy it.
- Have a **deployment account** with sufficient testnet funds (ETH for gas, and enough USDC if needed to seed initial actions).
- Set up environment variables or config files for:
  - `PRIVATE_KEY` of deployer,
  - RPC URL (e.g., `GOERLI_RPC_URL`),
  - Etherscan API key for verification.

**Deployment Steps**:
1. **Compile and Prepare Artifacts**: Use `forge build` (or Hardhat compile) to ensure the latest code is compiled. Generate ABI and bytecode for Token and Sale contracts. If using Hardhat, also generate TypeChain types for use in scripts.
2. **Deploy Proxy Contracts**:
   - Deploy the **Token implementation** contract first (Solidity code for token logic). Then deploy the **Proxy** pointing to that implementation. Using UUPS, the proxy is often a minimal `ERC1967Proxy` or similar. If using OpenZeppelin Upgrades plugin, a single call can deploy the proxy and implementation and call initialize.
   - After deployment, call the token’s `initialize(name, symbol, decimals, saleContractAddress, ...)`. However, at this moment we might not have the sale contract address yet. One approach: initialize token with no minter, then later give minter role to sale contract once that’s deployed. Alternatively, deploy sale first, then token, but sale’s initialize needs token address too – it’s a chicken-and-egg. We can deploy token first, initialize it with placeholder or just skip setting minter until sale is known.
   - We could initialize token with the deployer as a temporary minter, then deploy sale, then transfer minter role to sale. Or call token’s `grantRole(MINTER, saleAddress)` after sale is up. We must include this in deployment scripts.
   - Deploy the **Sale implementation** contract next. Then deploy the **Proxy** for the sale pointing to that implementation.
   - Call Sale’s `initialize(tokenAddr, usdcAddr, fundCreatorAddr, platformAddr, curveParams…)`. This will set up the sale state. The fundCreatorAddr likely is the same as deployer or a given team address. PlatformAddr is our platform’s address (maybe also deployer if we are simulating).
   - Within sale initialization, it might also store the Uniswap router address (if the contract itself will call it on finalize) or we set that in a variable.
3. **Post-Deployment Configuration**:
   - After both are deployed and initialized, call **token** contract’s `grantRole(MINTER_ROLE, saleContractAddress)` (if not done in initialize). This authorizes the sale to mint tokens. If using Ownable, it could be `transferOwnership(saleAddress)` if we made sale the owner who can mint. Ensure the sale contract can indeed mint/burn if needed.
   - If any initial seeding is needed (e.g., if bonding curve formula requires an initial reserve or initial token supply to set price), provide that. For example, Bancor formulas sometimes start with an initial reserve fund to avoid price = 0. We could seed a minimal USDC and mint few tokens to the pool at the very start (or define the curve such that at 0 supply, price is not 0). We might choose an initial price manually, so maybe not needed to seed externally.
   - Double-check all contract variables: Use `cast call` or scripts to read the token’s totalSupply (should be 0 initially if mint-on-demand) and sale’s sold tokens (0), etc.
4. **Verification**:
   - Use the appropriate tool to verify both contracts.
   - For the token and sale **implementation contracts**, verify with source code (including all library references). On Etherscan, mark them as proxy implementations.
   - For the **proxy contracts**, verify them as well. If using a standard OpenZeppelin proxy, Etherscan might auto-detect the proxy pattern. If not, we provide the proxy’s source (OpenZeppelin ERC1967Proxy code) for verification.
   - Once verified, the proxy’s page on Etherscan should ideally show a “Read/Write as Proxy” with our implementation’s ABI, allowing interactions through the proxy.
   - Save the Etherscan links and addresses.
5. **Testing on Testnet**:
   - Before involving many users, do a simple test: Using our scripts or even Etherscan’s interface, perform a small **buy**. We’ll need some USDC on the testnet:
     - If no official USDC, we might have deployed a mock USDC (ERC20) and given some to our test accounts. If so, use that address in sale initialization.
     - Approve a small amount of USDC from a test account to the sale contract and call `buyTokens(amount)`. Check that the account receives the expected tokens. This confirms the sale mechanism works outside of our local testing.
   - If everything looks good, we can simulate a full sale:
     - We might not realistically send 500M tokens worth of USDC (which might be huge) on a testnet. Instead, we can simulate completion by perhaps altering the contract in test or just triggering finalize after a partial sale for demonstration. However, ideally, we adhere to logic: maybe set our curve such that, for test, goal is reached with a smaller amount (like treat 500 tokens as if 500M for testing by scaling down parameters).
     - For demonstration, we could do: make 5 purchases of 100M tokens each (scaled down scenario, or 5 purchases of 100 tokens if we scaled supply down for test).
     - Finally, call `finalize`.
   - **Add Liquidity**:
     - If the finalize function is handling liquidity and we provided the Uniswap router address during init, then finalize will have executed `addLiquidity`. We then check on Uniswap:
       - If Uniswap V2: find the pair address via `factory.getPair(token, USDC)` if available, or capture event from router.
       - Check that pair’s reserves equal (250M tokens, X USDC).
       - If finalize did not handle liquidity (if we decided to do that off-chain for some reason), then run the off-chain script to add liquidity now. This requires we hold 250M tokens and equivalent USDC in an account (the fund creator’s account likely received both from finalize: they got 200M tokens + half USDC, but the other 250M tokens and USDC are still in contract? Actually in that scenario, contract should have them to add. But if not done, the contract might send 250M to founder as well and instruct them to add; but we planned to automate in contract).
       - So likely finalize already did it and there is no extra step.
   - The fund creator and platform should now have their token allocations. USDC split is done (half locked in LP, half to creator).
6. **Document Results**:
   - Write down the final contract addresses: 
     - Token proxy address (the main token address everyone will use),
     - Sale proxy address,
     - The Uniswap Pair address (if known) for reference,
     - Perhaps implementation addresses (not needed for users, but for admin reference).
   - These will go into the README and any submission details.

**Automation**: We can automate much of this via a script:
- A deploy script (Hardhat or Foundry script) that performs steps 2 and 3 in sequence.
- It can fetch addresses from the network (like known USDC or deploy a MockUSDC if needed, known Uniswap router).
- Using a config at top (addresses, parameters like reserve ratio).
- After deployment, the script can print all relevant addresses and perhaps attempt a test purchase as part of a “staging” routine.
- For verification, Hardhat’s plugin can verify right after deployment, or we run a separate verification script.

**Deployment on Different Networks**: Since the contracts are EVM-compatible, we can deploy similarly on any network (Polygon, BSC testnet, etc.). For a real mainnet launch, a few changes might be needed (like using real USDC address, perhaps adjusting gas usage if needed, and ensuring an audit is done prior).

**Handling Contingencies**:
- If something goes wrong (e.g., a bug found after deployment), thanks to UUPS, we can deploy a new implementation and call `upgradeTo` via our proxy admin. On testnet, we’ll try to avoid this by testing thoroughly beforehand, but it’s good to have the process ready (which we did test in Epics above).
- If Uniswap integration fails (say the router call reverts due to slippage or some issue), we’ll ensure to handle that error and perhaps allow trying finalize again or require manual liquidity addition. In testing, we will set parameters (like deadlines or slippage tolerance in addLiquidity call) to safe values to succeed.

The outcome of this deployment plan is a live, working token sale contract on a public test network, with verified source code and all features in place, ready for demonstration or further testing by stakeholders.

## Testing Strategy

Testing is critical for a project of this complexity, especially when handling financial logic and upgradability. We will use a **layered testing approach** with Foundry to cover every aspect:

- **Unit Testing** (with Foundry’s Forge):
  - These tests focus on individual functions and small interactions in isolation. We will create Solidity test contracts that directly call our token and sale contract functions and assert the expected results.
  - *Examples*: 
    - Test that `mint()` on the token works only when called from the sale contract (we can use Forge’s cheatcode to prank the caller identity to simulate unauthorized calls and expect reverts).
    - Test the math of the bonding curve by calling an internal pricing function with known inputs and verifying output (e.g., if reserve ratio and formula is known, for given USDC, known expected tokens).
    - Test boundary conditions like 0 USDC input (should revert or do nothing), maximum USDC (should mint exactly 500M tokens and then block further purchases).
    - Use **fuzz testing** for functions like `buyTokens`: Forge can generate random USDC amounts to ensure no combination causes overflow or miscalculation. We check invariants such as total supply <= 1B at all times.
  - Unit tests are fast and will be run frequently during development (every time we add a feature or fix a bug, run `forge test` to catch regressions).

- **Integration Testing** (with Foundry and possibly scripts):
  - Integration tests will simulate real-world scenarios and the interplay between multiple components. We prefer to use Solidity integration tests (in Forge) for on-chain interactions because we can manipulate time and actors easily.
  - *Scenario tests*:
    - **Full Sale Scenario**: In a single test, simulate a sequence: multiple users buy tokens (we can have an array of addresses and loop, each doing `buyTokens` with varying amounts), then finalize the sale. After finalize, verify:
      - Total tokens minted = 1B,
      - Balances of team, platform, pool are correct,
      - No USDC left in sale contract (it should either be in LP or distributed).
      - The price progression was monotonic increasing.
    - **Edge case: single buyer takes all**: one address buys the entire 500M in one go. Ensure the contract handles a large purchase in one transaction. This might test our formula’s handling of large input – if we’re doing incremental minting in a loop, could be gas-heavy; maybe our formula computes it directly. The test ensures performance is acceptable (within gas limits) for the worst-case transaction.
    - **Uniswap interaction**: In tests, we might not have actual Uniswap deployed, but we can **simulate** it:
      - Option 1: Deploy Uniswap Factory and Router in the setup of the test (there are scripts to deploy a minimal Uniswap v2 locally). Then feed our token and a MockUSDC into it. Our finalize will then call that deployed router. We can then query the created pair contract for reserves to confirm.
      - Option 2: Use a simpler stub: create a fake router contract in the test that has the same interface (`addLiquidity`) which just checks that the correct amounts are passed and then simulates an LP token mint by perhaps transferring back a dummy LP token. This way, we test that our contract calls router with expected values without needing full AMM logic.
      - Either way, integration test ensures that calling finalize indeed triggers the liquidity addition call and that tokens are deducted from the sale contract accordingly.
    - **Upgrade test**: Deploy v1, then upgrade to v2 in a test context. In Foundry, we can have two implementations compiled (perhaps `SaleV2` extends `Sale`). After upgrade, do a purchase and see that it uses new logic (maybe v2 changes a rate or emits a different event). This ensures our upgrade process doesn’t break anything.
  - Integration tests can also be done partially with scripts on a local fork:
    - For example, run an anvil (local node), deploy contracts via script, then use the TS/Python scripts to simulate users. This tests the scripts themselves as well as contract logic in one go.
    - We could incorporate that into a CI step or a separate manual test, e.g., a Hardhat test that uses the JS scripts to act as users. But likely the Foundry tests cover most of it.

- **Foundry Cheat Codes Utilization**:
  - We will heavily use cheat codes in tests:
    - `vm.prank(address)` to simulate calls from various users without needing actual separate keys.
    - `vm.warp(blockTimestamp)` to simulate time passing if we include any time-based conditions (like a sale closing after a deadline).
    - `vm.expectRevert` to ensure functions revert with correct error messages when invalid conditions are present (like buying after sale ended, or a non-admin trying to upgrade).
    - `vm.roll(blockNumber)` if needed to simulate new blocks (not particularly needed here except if using block number for some logic).
    - `vm.startPrank` / `vm.stopPrank` to simulate sequences of calls from one user conveniently.
    - `vm.deal(address, amount)` could be used to assign ether if needed for gas, not too relevant for our USDC logic.
    - For fuzzing, Forge provides `function invariant_X()` style or simply using `forge test --ffi` with a Python script for more complex invariant testing if needed.

- **Test Organization**:
  - We will separate tests by contract or feature:
    - `Token.t.sol` – cover all tests related to the ERC20 (minting, roles, transfers).
    - `Sale.t.sol` – unit tests for sale logic (buy, finalize under normal and abnormal conditions).
    - `Integration.t.sol` (or multiple files like `SaleFlow.t.sol`, `UpgradeTest.t.sol`) – for cross-contract scenarios and end-to-end flows as described.
  - Each test function will be named clearly about what it’s testing, and we’ll use comments to describe scenarios for complex tests for clarity.
  - Ensure tests are deterministic (for bonding curve math, any floating point notion is done with integer math; we might need to choose a fixed-point Q format for decimal math, e.g., multiply by 1e6 for precision if needed).
  - Foundry will give a coverage report by default; we aim to cover as many code paths as possible (ideally 100% of non-trivial code).

- **Manual Testing**:
  - In addition to automated tests, once deployed to testnet, we’ll do some manual testing:
    - Use Etherscan’s UI to call `buyTokens` and `finalize` to ensure they work in a live environment.
    - Possibly connect a Web3 wallet to a Uniswap front-end on testnet to see if our token appears and trading works after adding liquidity.
    - These manual tests catch any issues with real integration (like maybe gas limits or needing to approve USDC spending).

- **Testing Sale Economics**:
  - We will simulate extreme cases like if an attacker tries to manipulate the bonding curve by splitting buys into many small transactions vs one big transaction – our price formula is memoryless (depends only on current state), so it shouldn’t matter, but we can test that two small buys back-to-back yield roughly the same result as one combined buy in terms of total tokens acquired.
  - We will test that no one can bypass the bonding curve, e.g., ensure that the token contract doesn’t allow anyone else to mint tokens or that the sale contract’s price function can’t be bypassed by calling token mint directly (this is why we restrict minter roles).
  - If our bonding curve is complex, we might consider property-based tests or compare it against a known correct implementation (perhaps use the Bancor formula code on a small scale and ensure our outcomes match within a tolerance).

In summary, our testing strategy uses **Foundry for rapid, thorough testing** of both individual components and the system as a whole. We treat the smart contracts with the same rigor as production software: unit tests for every function and integration tests for every requirement scenario. The result will be a high-confidence codebase. All tests will be run and passing before deployment to the testnet, ensuring a smooth deployment.

## Repository Structure

Organizing the repository clearly will make it easier for others (and the user themselves) to navigate the project. We will use a structure that separates contracts, tests, and scripts, and includes configuration files at the top level:

- **Root Directory**:
  - `README.md` – The main documentation file with overview, instructions, etc. (as outlined in the Writeup Guide).
  - `foundry.toml` – Configuration for Foundry (including compiler version, remappings for libraries like OpenZeppelin, etc.).
  - `hardhat.config.ts` (optional) – If we use Hardhat for deployment or verification, we include a config file.
  - `.gitignore` – Ensuring we ignore artifacts, `.env` files with keys, etc.
  - `package.json` and `package-lock.json` – NodeJS project files if using Hardhat/TypeScript scripts. These will list dependencies like ethers, dotenv, etc.
  - `requirements.txt` or `Pipfile` – Python dependencies (maybe just `web3` library).
  - `.env.example` – An example environment file showing variables needed (like `RPC_URL`, `PRIVATE_KEY`, etc., without actual secrets).

- **Contracts Source**:
  - `contracts/` or `src/` – Contains Solidity source files.
    - `Token.sol` – The ERC20 token implementation (UUPSUpgradeable).
    - `Sale.sol` – The bonding curve sale contract.
    - `TokenProxy.sol` (if using a custom proxy, but likely we use standard so not needed as a file).
    - `SaleProxy.sol` (if needed).
    - We may also have:
      - `Mocks/` subfolder for any mock contracts used in testing (e.g., `MockUSDC.sol` if needed or `MockUniswapRouter.sol` for testing).
      - `Interfaces/` subfolder for external interfaces like `IUniswapV2Router02.sol` and `IUniswapV2Factory.sol`, and maybe `IERC20.sol` (though OZ ERC20 covers that).
      - `Libraries/` if we write any math library for the bonding curve (or we use an existing one).
    - We might keep the contracts flat in one folder since there are not too many, but logically grouping interfaces and mocks is helpful.

- **Test Directory**:
  - `test/` – Contains Foundry test contracts (which are Solidity files ending in `.t.sol` by convention).
    - `Token.t.sol` – tests for Token.sol.
    - `Sale.t.sol` – tests for Sale.sol.
    - `Integration.t.sol` (or more specific like `LaunchpadFlow.t.sol`) – integration tests covering combined behavior.
    - `Upgrade.t.sol` – tests related to proxy and upgrade.
    - Each test file will deploy the needed contracts in its setup and contain multiple test functions.
    - Possibly a `utils/` in test for any testing utility contracts (like a contract to receive tokens for testing or a contract that tries to re-enter, etc., if we wanted to test reentrancy protection).

- **Scripts Directory**:
  - `scripts/` – We will store deployment and interaction scripts here.
    - `Deploy.s.sol` – A Foundry script in Solidity to deploy contracts (if using Foundry scripting).
    - `deploy.ts` – A Hardhat script alternative to deploy (maybe we provide both options for demonstration).
    - `buyTokens.ts`, `finalizeSale.ts`, `addLiquidity.ts` – Node/TS scripts for user interactions as described.
    - `buy_tokens.py`, `check_status.py` – Python scripts for similar interactions.
    - We might separate TS and Python scripts into subfolders (e.g., `scripts/ts/*.ts` and `scripts/python/*.py`) to avoid confusion. But given there are only a couple, prefixing them clearly as `.ts` vs `.py` is probably enough.
    - If using Hardhat deploy, we might have a `scripts/deploy/` or use Hardhat’s `tasks` or `deploy` folder conventions (like using hardhat-deploy plugin), but not necessary.

- **Libs/Dependencies**:
  - Foundry often uses a `lib/` folder for git submodules (like `lib/openzeppelin-contracts` if we install via git). Or one can use Forge’s remappings to point to an npm installed OZ. Possibly we’ll use `forge install OpenZeppelin/openzeppelin-contracts`.
  - If Uniswap contracts are needed, we might include them similarly (or just the interface is enough).
  - `node_modules/` (not committed) for any JS dependencies.

- **CI/Config**:
  - `.github/workflows/ci.yml` – configuration for continuous integration (running tests and perhaps linting on pushes).
  - `solhint.json` or other linter configs if used.
  - `prettier.config.js` if needed for formatting JS/TS.

This structure isolates different parts of the project: one can look into `contracts` to see all smart contract code, into `test` to see how it’s verified, and `scripts` to see how to deploy/interact. The README at root ties it all together.

We will ensure that the **repository is structured logically** so that a reviewer can quickly find what they need:
- For example, if they want to see how the bonding curve is implemented, they go to `contracts/Sale.sol` and see comments and code.
- To see if tests cover a scenario, they open `test/Sale.t.sol`.
- To actually run the system, they follow instructions in README and maybe run `scripts/buyTokens.ts` after deploying.

## Writeup Guide (GitHub README)

The GitHub README will serve as the main **write-up** accompanying the code. It should give readers (and graders, if this is for a hackathon or assignment) a clear understanding of the project, how to use it, and how it meets the requirements. Below is an outline of what to include in the README:

1. **Project Overview**: 
   - A summary of the project’s purpose (e.g., “This project implements a decentralized token launchpad with a bonding curve sale mechanism, inspired by Bancor, enabling fundraising in USDC and automatic Uniswap listing.”).
   - Highlight key features (bonding curve pricing, upgradeability, automatic liquidity provisioning, etc.).
   - Perhaps a diagram or bullet list of the distribution (50% public, etc.) for quick visualization.

2. **Requirements and How They’re Met**:
   - Enumerate each requirement given (initiate fundraising in USDC, bonding curve, 1B supply, distribution breakdown, UUPS upgradeable, testnet deployment, etc.) and briefly note how the project fulfills it. For example:
     - *Fundraising in USDC*: The sale contract only accepts USDC (an address configurable on deployment). Buyers call `buyTokens` after approving USDC, etc.
     - *Bancor-style Bonding Curve*: Explain the formula or approach used. Possibly include the formula in the README with an explanation in simpler terms. Mention how initial buyers get more tokens per USDC (maybe give a small example: first buyer’s price vs last buyer’s price).
     - *Initial Supply 1B, Sell 500M*: Clarify that the smart contract enforces a cap of 500M tokens sold, and the token contract has a cap of 1B. Explain how the other 500M are allocated on finalize.
     - *Distribution on Completion*: Perhaps a small table: 
       | Allocation          | Amount (Tokens) | USDC          |
       |---------------------|-----------------|---------------|
       | Public Sale Buyers  | 500,000,000     | (they paid)   |
       | Fund Creator        | 200,000,000     | 50% of raise  |
       | Uniswap Pool (locked)| 250,000,000     | 50% of raise  |
       | Platform Fee        | 50,000,000      | 0 USDC        |
       This makes it explicit.
     - *UUPS Upgradeable*: Note that both contracts use the UUPS proxy pattern. Maybe link to OpenZeppelin docs or the RareSkills article for those interested. Emphasize that upgrade functions are restricted to the owner.
     - *Testnet Deployment*: Mention which network and provide the contract addresses (with hyperlinks to Etherscan). For example:
       - Token (Proxy) address on Goerli: `0xABC...123`.
       - Sale (Proxy) address on Goerli: `0xDEF...456`.
       - Uniswap (SushiSwap) Pair address: `0xPAIR...789` (if available).
       - USDC token used (if a custom test token, give address).
       - These allow anyone to verify and even interact (though maybe warn not to use real money on a testnet obviously).
     - *GitHub Repository & Code*: Well, the person reading is already on GitHub if reading README, but ensure to mention the code structure maybe here or later.

3. **Architecture**:
   - Provide a more detailed explanation of the architecture:
     - Describe the relationships: The sale contract holds no tokens initially if minting on the fly; it mints through the token contract. The token contract defers logic to sale for mint authorization.
     - Describe the sequence of events in the sale: 
       1. Fund creator (project) deploys contracts via launchpad.
       2. Investors approve and buy tokens.
       3. Price goes up along curve as supply increases.
       4. Sale ends at cap, finalize distribution happens.
       5. Uniswap pool is funded and trading begins.
     - Possibly include a flowchart or bullet points for these steps, to make it easy to follow.
     - Mention any important design patterns: e.g., using the **Circuit Breaker** pattern if we have emergency stop, or the rationale of upgradeable vs not upgradeable for each contract (maybe we made token upgradeable in case governance wants to add features).
     - Address how USDC is handled (since it’s an ERC20, user must approve, etc. – sometimes people forget that step in use, so call it out).
   
4. **Setup Instructions**:
   - Prerequisites: Node version, Foundry installation, etc.
   - How to install dependencies: `forge install` (for libs), `npm install` (for TS deps), `pip install -r requirements.txt` (for Python).
   - How to compile: `forge build` (and/or `npx hardhat compile`).
   - Configuration: setting up `.env` with RPC and keys if one plans to deploy or run scripts. Provide a template of what values are needed.
   - Running tests: `forge test -vvv` (perhaps suggest verbose mode to see details, or simply `forge test`).
   - Expectation from tests: all should pass. Mention if any tests are expected to fail or skipped (ideally none).
   
5. **Deployment and Usage**:
   - Explain how to deploy to a network:
     - If we provide a deploy script, show example usage, e.g., `npx hardhat run scripts/deploy.ts --network goerli`.
     - Or `forge script script/Deploy.s.sol:DeployScript --rpc-url $GOERLI_RPC_URL --private-key $PRIVATE_KEY --broadcast`.
     - Provide instructions on setting gas price or etherscan API if script does verification.
   - After deployment, how to initialize (if not done in script).
   - Provide the addresses if we deployed already (as per above in requirements mapping).
   - For usage:
     - **Buying tokens**: Show an example using Ethers (in code or CLI). E.g., “To buy tokens, first call USDC contract `approve(SaleAddress, amount)`, then call `buyTokens(amount)` on the sale contract. You will receive tokens in return. Check your balance by calling `balanceOf` on token contract.”
     - **Finalizing sale**: “Once 500M tokens are sold (or the sale is ended by admin if applicable), the fund creator calls `finalize()`. This will automatically distribute tokens and add liquidity. After this, no more purchases are allowed and the sale is closed.”
     - **Trading**: “After finalize, you can trade the token on Uniswap. The initial pool has been created at address ... You can go to Uniswap UI (if applicable with custom token address input) to trade. The pair is Token/USDC.”
     - **Upgrading**: Document how to perform an upgrade in case someone needs to. For example: “The owner (platform) can upgrade the implementation. We included a dummy `V2` contract in contracts/ for demonstration. To upgrade, call `upgradeTo(newImplementationAddress)` from the proxy (via Hardhat or Etherscan as owner). The new implementation must have the same storage layout and also be UUPS (with security checks).”
     - Emphasize that upgrading is a powerful feature but also a risk if misused (possibly mention that the owner could theoretically change the contract – which might be fine as this is a launchpad scenario and presumably trustable, or if not, there could be a governance mechanism).
   
6. **Testing/Development**:
   - Encourage reading the tests to understand specifics. Mention that Foundry tests cover various scenarios. If any special command is needed (like if we had to fork mainnet to test Uniswap, we’d mention use of `FOUNDRY_FORK_URL` etc).
   - Possibly show a snippet of a successful test run or an example output from an integration test (like log of a simulated sale).
   - If gas reports are produced (Foundry can do gas snapshots), maybe include some gas cost info for functions (not required, but some submissions like to show gas efficiency).
   - If the bonding curve formula is complex, maybe mention how we tested it (e.g., compared to theoretical values).
   
7. **Future Improvements**:
   - Although not explicitly asked, a brief section on what could be improved or added:
     - E.g., adding a feature for a time limit on the sale, or refund if goal not reached (though here goal is reached by design).
     - Perhaps implementing a governance or timelock on upgrades to decentralize trust.
     - Enhancing the bonding curve to be configurable (maybe different curves for different sales).
     - UI frontend for easier interaction (we only did scripts).
     - This shows insight and that we thought beyond just what was asked.
   
8. **Conclusion**:
   - End with a note reinforcing that all requirements were achieved and tested. Invite readers to test the contracts themselves on testnet. Provide contact or anything if relevant (for actual launchpad, maybe they'd have social links, but for our case, not needed).
   - If this were a professional README, perhaps also include licensing information (likely MIT/Open source) and acknowledge any libraries (OpenZeppelin, etc.).

Throughout the README, the tone should be clear and professional, making it understandable even to someone who isn’t deeply familiar with our code. Given this is for a submission, we ensure it's not just technical but also somewhat persuasive that our solution is solid.

The **Write-up/README** will essentially be a polished, user-friendly version of what we have outlined in this document, with perhaps less technical detail in some sections (like not the entire test plan, but key points of it). It should be possible for the evaluator to read the README and get a holistic picture, then dive into specific areas of the code or tests if needed.

By following this guide for the write-up, we ensure the final submission is comprehensive, fulfilling not only the technical requirements but also clearly communicating that fulfillment.